# 数学游戏技能错题算法设计文档

## 概述

本文档详细描述了数学游戏中每个技能（skill）的错误答案生成算法。这些算法旨在制造特定类型的错误，以测试学生在不同数学技能上的掌握程度。

## 核心设计原则

1. **精准技能定位**: 每个错题只针对一个特定技能
2. **错误类型明确**: 错误答案应该能反映学生在该技能上的典型错误
3. **干扰性最小**: 避免一个错题同时触发多个技能的错误
4. **数值合理**: 错误答案应该在合理的数值范围内

## 技能算法详解

### 1. lastDigit (个位数技能)

**目标**: 测试学生对个位数计算的准确性

**算法描述**:
```
给正确答案加减1-5的随机值（排除0）
变化范围: ±1 到 ±5
允许影响其他位数（如进位、借位）
```

**实现逻辑**:
```typescript
case 'lastDigit':
  // 生成-5到+5的随机变化（排除0）
  let lastDigitChange
  do {
    lastDigitChange = Math.floor(Math.random() * 11) - 5 // -5 到 5
  } while (lastDigitChange === 0)
  v = correct + lastDigitChange
```

**示例**:
- 正确答案: 123 → 错误答案: 118/128/125/126/127
- 正确答案: -456 → 错误答案: -451/-461/-455/-454/-453

**验证标准**:
- 数值变化在±5范围内且不为0
- 不强制要求个位数单独变化

---

### 2. estimate (估算技能)

**目标**: 测试学生对数值估算和首位数感知的能力

**算法描述**:
```
方案1 (50%概率): 修改首位数字±1
  - 两位数及以上: 修改最高位±1
  - 一位数: 直接±1

方案2 (50%概率): 插入或删除中间数字
  - 插入: 在中间位置随机插入0-9的数字
  - 删除: 删除中间位置（非首位）的数字

约束条件: 保持个位数不变
```

**实现逻辑**:
```typescript
case 'estimate':
  if (Math.random() < 0.5) {
    // 方案1：修改首位
    const digits = absCorrect.toString().length
    if (digits >= 2) {
      const highestPlace = Math.pow(10, digits - 1)
      let change
      do {
        change = Math.floor(Math.random() * 3) - 1 // -1 到 1，排除0
      } while (change === 0)
      v = correct + change * highestPlace
    } else {
      // 一位数处理
      v = correct + (Math.random() < 0.5 ? 1 : -1)
    }
  } else {
    // 方案2：插入/删除数字
    // ... 插入删除逻辑
  }
  // 保持个位数
  const originalLastDigit = Math.abs(correct % 10)
  if (correct < 0) {
    v = Math.floor(Math.abs(v) / 10) * 10 + originalLastDigit
    v = -v
  } else {
    v = Math.floor(v / 10) * 10 + originalLastDigit
  }
```

**示例**:
- 正确答案: 123 → 错误答案: 223 (首位+1) 或 1023 (插入0)
- 正确答案: 456 → 错误答案: 556 (首位+1) 或 4656 (插入6)
- 正确答案: 78 → 错误答案: 178 (首位+1) 或 708 (插入0)

**验证标准**:
- 位数发生变化 或 首位数字发生变化
- 个位数保持不变

---

### 3. carryBorrow (进位/借位技能)

**目标**: 测试学生对进位和借位运算的理解

**算法描述**:
```
给正确答案加减±10或±20
随机选择变化幅度和方向
保持个位数完全不变
```

**实现逻辑**:
```typescript
case 'carryBorrow':
  const carryError = (Math.random() < 0.5 ? 10 : 20) * (Math.random() < 0.5 ? 1 : -1)
  v = correct + carryError
```

**示例**:
- 正确答案: 123 → 错误答案: 133/143/113/103
- 正确答案: -456 → 错误答案: -446/-436/-466/-476
- 正确答案: 78 → 错误答案: 88/98/68/58

**验证标准**:
- 数值变化为±10或±20
- 个位数保持不变

---

### 4. parity (奇偶性技能)

**目标**: 测试学生对奇偶性概念的掌握

**算法描述**:
```
根据正确答案的奇偶性，调整为相反的奇偶性
偶数→奇数: +1
奇数→偶数: -1
```

**实现逻辑**:
```typescript
case 'parity':
  v = correct + (correct % 2 === 0 ? 1 : -1)
```

**示例**:
- 正确答案: 123 (奇数) → 错误答案: 122 (偶数)
- 正确答案: 456 (偶数) → 错误答案: 457 (奇数)

**验证标准**:
- 奇偶性与正确答案相反

---

### 5. specialDigits (特殊数字技能)

**目标**: 测试学生对3和9整除性的理解

**算法描述**:
```
目标: 破坏原数的3或9整除性，但保持个位数不变

策略:
1. 计算3和9的整除性目标值
2. 尝试不同数量级的变化 (±10, ±100, ±1000)
3. 寻找满足条件的候选值
4. 如未找到，尝试更大范围变化 (±5000-±10000)
5. 最后回退: ±100变化
```

**实现逻辑**:
```typescript
case 'specialDigits':
  const currentSum = digitSum(correct)
  const targetMod3 = (currentSum % 3 + 1) % 3 // 确保不被3整除
  const targetMod9 = (currentSum % 9 + 1) % 9 // 确保不被9整除
  const modTarget = Math.random() < 0.7 ? targetMod3 : targetMod9

  const magnitudes = [10, 100, 1000]
  let found = false

  // 主要搜索策略
  for (let attempt = 0; attempt < 50 && !found; attempt++) {
    const magnitude = magnitudes[Math.floor(Math.random() * magnitudes.length)]
    for (let i = 1; i <= magnitude / 10 && i <= 100; i++) {
      const testDiff = i * magnitude * (Math.random() < 0.5 ? 1 : -1)
      const candidate = correct + testDiff
      const candidateLastDigit = Math.abs(candidate % 10)
      if (candidateLastDigit === lastDigit) {
        const candidateSum = digitSum(candidate)
        if ((modTarget === targetMod3 && candidateSum % 3 !== currentSum % 3) ||
            (modTarget === targetMod9 && candidateSum % 9 !== currentSum % 9)) {
          v = candidate
          found = true
          break
        }
      }
    }
  }

  // 扩大搜索范围
  if (!found) {
    for (let attempt = 0; attempt < 20 && !found; attempt++) {
      const largeChange = (Math.random() < 0.5 ? 1 : -1) * (5000 + Math.floor(Math.random() * 5000))
      const candidate = correct + largeChange
      const candidateLastDigit = Math.abs(candidate % 10)
      if (candidateLastDigit === lastDigit) {
        const candidateSum = digitSum(candidate)
        if ((modTarget === targetMod3 && candidateSum % 3 !== currentSum % 3) ||
            (modTarget === targetMod9 && candidateSum % 9 !== currentSum % 9)) {
          v = candidate
          found = true
          break
        }
      }
    }
  }

  // 回退方案
  if (!found) {
    const diff = 100 * (Math.random() < 0.5 ? 1 : -1)
    v = correct + diff
  }
```

**示例**:
- 正确答案: 123 (数字和=6, 可被3整除) → 错误答案: 133 (数字和=7, 不被3整除)
- 正确答案: 456 (数字和=15, 可被3整除) → 错误答案: 466 (数字和=16, 不被3整除)

**验证标准**:
- 3或9的整除性发生变化
- 个位数保持不变

---

### 6. castingOutNines (弃九验算技能)

**目标**: 测试学生对弃九验算方法的掌握

**算法描述**:
```
目标: 改变弃九模9结果，但保持个位数不变

策略优先级:
1. 修改十位数 (±10-±90)
2. 修改百位数 (±100-±900)
3. 修改千位数 (±1000-±9000)
4. 组合变化 (±9, ±18, ±27, ... ±81)
```

**实现逻辑**:
```typescript
case 'castingOutNines':
  const currentMod9_value = digitSumMod9(correct)
  const wrongMod9_value = (currentMod9_value + 1) % 9 || 9

  const strategies = [
    // 策略1: 修改十位数
    () => {
      for (let tensChange = -9; tensChange <= 9; tensChange++) {
        if (tensChange === 0) continue
        const candidate = correct + tensChange * 10
        const candidateLastDigit = Math.abs(candidate % 10)
        if (candidateLastDigit === lastDigit && digitSumMod9(candidate) === wrongMod9_value) {
          return candidate
        }
      }
      return null
    },
    // 策略2: 修改百位数
    () => {
      for (let hundredsChange = -9; hundredsChange <= 9; hundredsChange++) {
        if (hundredsChange === 0) continue
        const candidate = correct + hundredsChange * 100
        const candidateLastDigit = Math.abs(candidate % 10)
        if (candidateLastDigit === lastDigit && digitSumMod9(candidate) === wrongMod9_value) {
          return candidate
        }
      }
      return null
    },
    // 策略3: 修改千位数
    () => {
      for (let thousandsChange = -9; thousandsChange <= 9; thousandsChange++) {
        if (thousandsChange === 0) continue
        const candidate = correct + thousandsChange * 1000
        const candidateLastDigit = Math.abs(candidate % 10)
        if (candidateLastDigit === lastDigit && digitSumMod9(candidate) === wrongMod9_value) {
          return candidate
        }
      }
      return null
    },
    // 策略4: 组合变化
    () => {
      const baseChanges = [9, 18, 27, 36, 45, 54, 63, 72, 81]
      for (let change of baseChanges) {
        const candidate1 = correct + change
        const candidate2 = correct - change
        const candidate1LastDigit = Math.abs(candidate1 % 10)
        const candidate2LastDigit = Math.abs(candidate2 % 10)
        if (candidate1LastDigit === lastDigit && digitSumMod9(candidate1) === wrongMod9_value) {
          return candidate1
        }
        if (candidate2LastDigit === lastDigit && digitSumMod9(candidate2) === wrongMod9_value) {
          return candidate2
        }
      }
      return null
    }
  ]

  // 尝试所有策略
  for (let strategy of strategies) {
    const result = strategy()
    if (result !== null) {
      v = result
      foundCasting = true
      break
    }
  }
```

**示例**:
- 正确答案: 123 (弃九模9=6) → 错误答案: 133 (弃九模9=7)
- 正确答案: 456 (弃九模9=6) → 错误答案: 466 (弃九模9=7)
- 正确答案: 789 (弃九模9=6) → 错误答案: 699 (弃九模9=6，不符合，继续搜索)

**验证标准**:
- 弃九模9结果发生变化
- 个位数保持不变

---

## 辅助函数

### digitSum(n: number): number
计算数字各位数之和，用于3和9整除性判断。

### digitSumMod9(n: number): number
计算数字各位数之和模9的结果，用于弃九验算。

## 负数处理原则

所有算法都遵循以下负数处理原则：

1. **个位数计算**: 使用 `Math.abs(n % 10)` 获取绝对值的个位数
2. **个位数保持**: 确保错误答案的个位数与正确答案的个位数（绝对值）相同
3. **数值变化**: 直接在原数值基础上进行加减运算，保持符号

## 当前测试状态

- **castingOutNines**: 100% ✅
- **estimate**: 93.5%
- **specialDigits**: 79.5%
- **lastDigit**: 80%
- **carryBorrow**: 76.5%

## 优化方向

1. **specialDigits**: 优化3/9整除性变化的搜索算法
2. **estimate**: 改进首位变化和数字插入/删除的逻辑
3. **carryBorrow**: 确保严格满足±10/±20的要求
4. **lastDigit**: 改进±5范围变化的精确控制

---

*文档版本: v1.0*
*最后更新: 2025-10-02*
*对应代码: src/game/managers/QuestionGenerator.ts*